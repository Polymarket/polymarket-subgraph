# Generic

type Global @entity {
  "ID is empty string, this is a singleton"
  id: ID!
  numConditions: Int!
  numOpenConditions: Int!
  numClosedConditions: Int!
  "Global volume in USDC base units"
  usdcVolume: BigInt!
  "Global volume in USDC scaled by 10^6"
  scaledUsdcVolume: BigDecimal!
  "Global fees in USDC base units"
  usdcFees: BigInt!
  "Global fees in USDC scaled by 10^6"
  scaledUsdcFees: BigDecimal!
}

type Account @entity {
  "User address"
  id: ID!
  "Markets in which user has provided liquidity"
  fpmmPoolMemberships: [FpmmPoolMembership!] @derivedFrom(field: "funder")
  "Markets in which the user has taken a position on the outcome"
  marketPositions: [MarketPosition!] @derivedFrom(field: "user")
  "Purchases and sales of shares by the user"
  transactions: [Transaction!] @derivedFrom(field: "user")
  "Redemption of underlying collateral after a market has resolved"
  redemptions: [Redemption!] @derivedFrom(field: "redeemer")
}

type Collateral @entity {
  "Token address"
  id: ID!
  name: String!
  symbol: String!
  decimals: Int!
}

# Conditional Tokens

type Condition @entity {
  id: ID!
  "Address which can resolve this condition"
  oracle: Bytes!
  questionId: Bytes!
  outcomeSlotCount: Int!
  resolutionTimestamp: BigInt
  "Fraction of collateral assigned to each outcome"
  payouts: [BigDecimal!]
  payoutNumerators: [BigInt!]
  payoutDenominator: BigInt
  "Market makers which are trading on this condition"
  fixedProductMarketMakers: [FixedProductMarketMaker!]!
}

type Split @entity {
  "Transaction Hash"
  id: ID!
  "Address which is performing this split"
  stakeholder: Account!
  collateralToken: Collateral!
  parentCollectionId: Bytes!
  condition: Condition!
  partition: [BigInt!]!
  amount: BigInt!
}

type Merge @entity {
  "Transaction Hash"
  id: ID!
  "Address which is performing this merge"
  stakeholder: Account!
  collateralToken: Collateral!
  parentCollectionId: Bytes!
  condition: Condition!
  partition: [BigInt!]!
  amount: BigInt!
}

type Redemption @entity {
  "Transaction Hash"
  id: ID!
  "Address which is redeeming these outcomes"
  redeemer: Account!
  collateralToken: Collateral!
  parentCollectionId: Bytes!
  condition: Condition!
  "Outcomes which are being redeemed"
  indexSets: [BigInt!]!
  payout: BigInt!
}

# Market Makers

type FixedProductMarketMaker @entity {
  "Market maker address"
  id: ID!

  "Address which deployed this market"
  creator: Bytes!
  "Time at which this market was deployed"
  creationTimestamp: BigInt!

  "Token which is colleralising this market"
  collateralToken: Collateral!
  "Conditions which this market is trading against"
  conditions: [Condition!] @derivedFrom(field: "fixedProductMarketMakers")
  "Percentage fee of trades taken by market maker. A 2% fee is represented as 2*10^16"
  fee: BigInt!

  "Number of trades of any kind against this market maker"
  tradesQuantity: BigInt!
  "Number of purchases of shares from this market maker"
  buysQuantity: BigInt!
  "Number of sales of shares to this market maker"
  sellsQuantity: BigInt!

  "Market volume in terms of the underlying collateral value"
  collateralVolume: BigInt!
  "Volume scaled by the number of decimals of collateralToken"
  scaledCollateralVolume: BigDecimal!
  "Fees collected in terms of the underlying collateral value"
  feeVolume: BigInt!
  "Fees scaled by the number of decimals of collateralToken"
  scaledFeeVolume: BigDecimal!

  "Constant product parameter k"
  liquidityParameter: BigInt!
  scaledLiquidityParameter: BigDecimal!

  "Balances of each outcome token held by the market maker"
  outcomeTokenAmounts: [BigInt!]!
  "Prices at which market maker values each outcome token"
  outcomeTokenPrices: [BigDecimal!]!
  "Number of outcomes which this market maker is trading"
  outcomeSlotCount: Int

  "Timestamp of last day during which someone made a trade"
  lastActiveDay: BigInt!

  "Number of shares for tokens in the market maker's reserves"
  totalSupply: BigInt!

  "Addresses which are supplying liquidity to the market maker"
  poolMembers: [FpmmPoolMembership!] @derivedFrom(field: "pool")
}

type MarketPosition @entity {
  id: ID!
  "Market on which this position is on"
  market: FixedProductMarketMaker!
  "Address which holds this position"
  user: Account!
  "The outcome which this position is supporting"
  outcomeIndex: BigInt!
  "Number of outcome shares that the user has ever bought"
  quantityBought: BigInt!
  "Number of outcome shares that the user has ever sold"
  quantitySold: BigInt!
  "Number of outcome shares that the user current has"
  netQuantity: BigInt!
  "Total value of outcome shares that the user has bought"
  valueBought: BigInt!
  "Total value of outcome shares that the user has sold"
  valueSold: BigInt!
  "Total value paid by the user to enter this position"
  netValue: BigInt!
}

# Market Actions

type FpmmFundingAddition @entity {
  "Transaction Hash"
  id: ID!
  timestamp: BigInt!
  fpmm: FixedProductMarketMaker!
  funder: Account!
  amountsAdded: [BigInt!]!
  amountsRefunded: [BigInt!]!
  sharesMinted: BigInt!
}

type FpmmFundingRemoval @entity {
  "Transaction Hash"
  id: ID!
  timestamp: BigInt!
  fpmm: FixedProductMarketMaker!
  funder: Account!
  amountsRemoved: [BigInt!]!
  collateralRemoved: BigInt!
  sharesBurnt: BigInt!
}

enum TradeType {
  Buy
  Sell
}

type Transaction @entity {
  "Transaction Hash"
  id: ID!
  type: TradeType!
  timestamp: BigInt!
  market: FixedProductMarketMaker!
  user: Account!
  tradeAmount: BigInt!
  feeAmount: BigInt!
  outcomeIndex: BigInt!
  outcomeTokensAmount: BigInt!
}

type FpmmPoolMembership @entity {
  id: ID!
  pool: FixedProductMarketMaker!
  funder: Account!
  amount: BigInt!
}

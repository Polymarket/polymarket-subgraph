# Generic

type Global @entity {
  # ID is empty string, this is a singleton
  id: ID!
  numConditions: Int!
  numOpenConditions: Int!
  numClosedConditions: Int!
}

type Account @entity {
  id: ID!
  # Which markets has user provided liquidity to
  fpmmPoolMemberships: [FpmmPoolMembership!] @derivedFrom(field: "funder")
  # Which markets has user bought shares in
  fpmmParticipations: [FpmmParticipation!] @derivedFrom(field: "participant")
  marketPositions: [MarketPosition!] @derivedFrom(field: "user")
  transactions: [Transaction!] @derivedFrom(field: "user")
  redemptions: [Redemption!] @derivedFrom(field: "redeemer")
}

# Conditional Tokens

type Condition @entity {
  id: ID!
  oracle: Bytes!
  questionId: Bytes!
  outcomeSlotCount: Int!
  resolutionTimestamp: BigInt
  payouts: [BigDecimal!]
  payoutNumerators: [BigInt!]
  payoutDenominator: BigInt
  fixedProductMarketMakers: [FixedProductMarketMaker!]!
}

type Split @entity {
  id: ID!
  stakeholder: Account!
  collateralToken: Bytes!
  parentCollectionId: Bytes!
  condition: Condition!
  partition: [BigInt!]!
  amount: BigInt!
}

type Merge @entity {
  id: ID!
  stakeholder: Account!
  collateralToken: Bytes!
  parentCollectionId: Bytes!
  condition: Condition!
  partition: [BigInt!]!
  amount: BigInt!
}

type Redemption @entity {
  id: ID!
  redeemer: Account!
  collateralToken: Bytes!
  parentCollectionId: Bytes!
  condition: Condition!
  indexSets: [BigInt!]!
  payout: BigInt!
}

# Market Makers

type FixedProductMarketMaker @entity {
  id: ID!

  creator: Bytes!
  creationTimestamp: BigInt!

  collateralToken: Bytes!
  conditions: [Condition!] @derivedFrom(field: "fixedProductMarketMakers")
  fee: BigInt!

  collateralVolume: BigInt!
  scaledCollateralVolume: BigDecimal!
  feeVolume: BigInt!
  scaledFeeVolume: BigDecimal!
  outcomeTokenAmounts: [BigInt!]!
  outcomeTokenPrices: [BigDecimal!]!
  outcomeSlotCount: Int
  liquidityParameter: BigInt!
  scaledLiquidityParameter: BigDecimal!

  lastActiveDay: BigInt!
  runningDailyVolume: BigInt!
  scaledRunningDailyVolume: BigDecimal!
  lastActiveDayAndRunningDailyVolume: BigInt!
  lastActiveDayAndScaledRunningDailyVolume: BigInt!

  collateralVolumeBeforeLastActiveDay: BigInt!

  totalSupply: BigInt!

  poolMembers: [FpmmPoolMembership!] @derivedFrom(field: "pool")
  participants: [FpmmParticipation!] @derivedFrom(field: "fpmm")
}

type MarketPosition @entity {
  id: ID!
  market: FixedProductMarketMaker!
  user: Account!
  outcomeIndex: BigInt!
  # number of outcome shares that the user has bought and sold.
  quantityBought: BigInt!
  quantitySold: BigInt!
  netQuantity: BigInt!
  # total value paid by the user to enter this position.
  # if valueSold > valueBought then the user has cashed out at a profit.
  valueBought: BigInt!
  valueSold: BigInt!
  netValue: BigInt!
}

type FpmmFundingAddition @entity {
  id: ID!
  timestamp: BigInt!
  fpmm: FixedProductMarketMaker!
  funder: Account!
  amountsAdded: [BigInt!]!
  amountsRefunded: [BigInt!]!
  sharesMinted: BigInt!
}

type FpmmFundingRemoval @entity {
  id: ID!
  timestamp: BigInt!
  fpmm: FixedProductMarketMaker!
  funder: Account!
  amountsRemoved: [BigInt!]!
  collateralRemoved: BigInt!
  sharesBurnt: BigInt!
}

type Transaction @entity {
  id: ID!
  type: String!
  timestamp: BigInt!
  market: FixedProductMarketMaker!
  user: Account!
  tradeAmount: BigInt!
  feeAmount: BigInt!
  outcomeIndex: BigInt!
  outcomeTokensAmount: BigInt!
}

type FpmmPoolMembership @entity {
  id: ID!
  pool: FixedProductMarketMaker!
  funder: Account!
  amount: BigInt!
}

type FpmmParticipation @entity {
  id: ID!
  fpmm: FixedProductMarketMaker!
  participant: Account!
}
